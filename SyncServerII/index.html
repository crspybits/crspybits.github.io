<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>SyncServerII</title> 

    <!-- Bootstrap core CSS -->
    <link href="bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="ie10-viewport-bug-workaround.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="jumbotron.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <style>
      p {
        font-size:14pt;
      }
      
      .row-striped:nth-of-type(odd){
        background-color: #efefef;
      }

      .row-striped:nth-of-type(even){
        background-color: #F0F8FF;
      }
      
      .padded {
        padding: 1em;
      }
      
      /* For the *destination* of an in-document anchor */
      a.anchor {
          display: block;
          position: relative;
          top: -50px;
          visibility: hidden;
      }
      
      ol, ul {
        font-size:16pt;
      }
      
      li {
        padding-top:2pt;
      }
    </style>
  </head>
  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://github.com/crspybits/SyncServerII">SyncServerII</a>
        </div>
      </div>
    </nav>

    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron">
      <div class="container">
        <h1>SyncServerII Framework</h1>
        <p>SyncServerII is a framework and server with these main goals:</p>
        <ul>
          <li>Synchronize a mobile app’s data across mobile devices and user-owned cloud storage systems (e.g., Google Drive, Dropbox), and</li>
          <li>Enable mobile app users to safely share that cloud data with other users (e.g., Google, Facebook, Dropbox).</li>
        </ul>
      </div>
    </div>

    <div class="container">
      <div class="row row-striped padded">
        <h2>Contents:</h2>
        <ul>
          <li>General</li>
            <h3><a href="#DEVSTATUS">Development Status</a></h3>
            <h3><a href="#USECASES">Use Cases</a></h3>
            <h3><a href="#CONCEPTS">Concepts and Terminology</a></h3>
            <h3><a href="#LIMITATIONS">Current Limitations</a></h3>
          <li>Code Docs</li>
            <h3><a href="#CLIENT_API">Client Interface Documentation</a></h3>
          <li>Installation</li>
            <h3><a href="#INSTALLSERVER">Standing up a Server</a></h3>
            <h3><a href="#INSTALLAPP">Installation in a new iOS app</a></h3>
            <h3><a href="#GOOGLE">Using Google Drive and Google Sign-In (optional)</a></h3>
            <h3><a href="#FACEBOOK">Using Facebook Sign-In (optional)</a></h3>
            <h3><a href="#DROPBOX">Using Dropbox Sign-In (optional)</a></h3>
            <h3><a href="#FURTHERREADING">Further Reading &amp; Viewing</a></h3>
        </ul>
      </div>
      
      <a class="anchor" id="DEVSTATUS"></a>
      <div class="row row-striped padded">
        <h2>Development Status</h2>
        <ul>
          <li>Google Drive and Dropbox are supported in terms of cloud storage systems.</li>
          <li>Google, Dropbox, and Facebook sign-in's are supported (Facebook is only for sharing; Dropbox is only for owning).</li>
          <li>Optimistic synchronization is used for ensuring clients have a consistent view of data (e.g., <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.8.7606&rep=rep1&type=pdf">see</a>).</li>
          <li>Sharing can be done with permissions of read, write (includes read), or admin (read, write and invite others to share).</li>
          <li>Multi-version files and multi-version per-file meta data.</li>
          <li>File content conflicts and meta-data conflicts are resolved with application defined conflict resolution rules.</li>
          <li>Support for application-specific groups of files so that downloads are presented to applications in terms of changes to those groups.</li>
          <li>Builds of releases of the server are published to <a href="https://hub.docker.com/r/crspybits/syncserver-runner/">hub.docker</a>.</li>
          <li>An example server is currently running on the AWS Elastic Beanstalk, 
              supporting the <a href="http://github.com/crspybits/SharedImages">SharedImages</a> iPhone/iPad app</li>

          <li>Repos for this system are:</li>
            <ul>
              <li><a href="https://github.com/crspybits/SyncServerII">SyncServerII server</a></li>
              
              <li><a href="https://github.com/crspybits/SyncServer-Shared">Swift files shared between client and server</a></li>
                In the form of a Cocoapod.
              
              <li><a href="https://github.com/crspybits/SyncServer-iOSClient">iOS Client for the SyncServer server.</a></li>
              
              <li><a href="http://github.com/crspybits/SharedImages">SharedImages</a></li>
                Demo iOS app-- Uses the <a href="https://github.com/crspybits/SyncServer-iOSClient">iOS Client</a>, enables images and discussion threads to be synchronized across mobile devices &amp; user-owned cloud storage, enables safe sharing of those images with others, and safe sharing of discussion threads.
            </ul>
        </ul>  
      </div>

      <a class="anchor" id="USECASES"></a>
      <div class="row row-striped padded">
        <h2>Use Cases</h2>

        <div style="margin-left: 1em">
          <h3>1) Private Social Media</h3>
          <div style="margin-left: 2em">
            <p><em>Current social media</em>: Data is stored on corporate servers; users can lose  
                ownership of data both “physically” and in terms of intellectual property.
            </p>
            <p><em>If mobile app developer makes use of SyncServer</em>:
              <ul>
                <li>Data content (e.g., images) is stored in app users cloud (e.g., Google Drive)</li>
                <li>Data can also be safely shared with friends through various sign-in methods (e.g., Facebook)</li>
                <li>Users retain intellectual property rights</li>
                <li>The data is not searchable on search engines, and has that privacy.</li>
              </ul>
            </p>
          </div>
        </div>

        <div style="margin-left: 1em">
          <h3>2) Data Longevity</h3>
          <div style="margin-left: 2em">
            <p><em>Apps sometimes hide their data</em>:
              For example, you enter your favorite restaurant meals and preferences, and images of those events into an app
              <ul>
                <li>App stores data internally</li>
                <li>If app stops being supported, users lose access to data</li>
                <li>If you lose your device or your backup fails, you lose access to data</li>
              </ul>
            </p>

            <p><em>If mobile app developer makes use of SyncServer</em>:
              <ul>
                <li>Data is stored in normal files (not in special database or 
                  otherwise obscured formats)</li>
                <li>Data is stored in normal places in users cloud storage.</li>
                  E.g., in Dropbox, /Apps/AppName/YourFiles
                <li>Also enables backup and recovery in the same manner</li>
              </ul>
            </p>
          </div>
        </div>

        <div style="margin-left: 1em">
          <h3>3) Developers Save $$$</h3>
          <div style="margin-left: 2em">
            <ul>
              <li>Why should developers or small companies pay for storing users data?</li>
              <li>SyncServer stores content data in users own cloud storage</li>
              <li>Meta-data (e.g., file identifiers, version numbers), &amp; some user credentials are stored in SyncServerII</li>
              <li>Estimate from SharedImages: SyncServerII data is about 1/100th size of user owned content data</li>
            </ul>
          </div>
        </div>
      </div>

      <a class="anchor" id="CONCEPTS"></a>
      <div class="row row-striped padded">
        <h2>Concepts and Terminology</h2>
        <ul>
          <li>General</li>
          <ul>
            <li>Sharing User Groups</li>
              <div>
                <p style="margin-left: 1em">
                  Sharing is a key element in the design of SyncServer: It enables groups of users to share files.
                  An initial user starts a sharing group by creating an account on a SyncServer-based app -- using their cloud storage system credentials (e.g., Google Drive or Dropbox).
                  This initial user is termed an <em>owning</em> user because they own the files they upload to the cloud storage system.
                  They can then expand the number of the users in the group by inviting other users to share their files-- these other users are invited with specific permissions: read, write, or admin.
                  Users invited with admin permissions can invite others to the group, and expand the number of users sharing the files in the group.
                  Currently (6/2/18), only the initial user in a group can be the owning user.
                  When other users upload files, they all are uploaded into that owning users cloud storage.
                  This situation is planned to change shortly, however.
                  <a href="https://github.com/crspybits/SyncServerII/issues/74">Other users who join the sharing group with cloud storage credentials will own the files they upload.</a>
                </p>
                <p></p>
                <img src="Figures/SingleUserSharingGroup.png" style="width: 100%; height: auto;"/>
                <p></p>
                <p style="margin-left: 1em">
                  The figure above depicts a user group after <a href="https://github.com/crspybits/SyncServerII/issues/74">the change to have multiple owning users per sharing group</a>.
                  Note that all access to cloud storage is routed through the SyncServerII server, and so controls the access that others have to a single users cloud storage.
                  That is, I only grant the sharing group access to specific files in my cloud storage, and only with specific permissions.
                </p>
              </div>

            <li>Owning versus Sharing</li>
              <p style="margin-left: 1em">
                Users who have their uploaded files stored in their own cloud storage are termed <em>owning users</em>. 
                Users who sign in with non-cloud storage accounts (e.g., Facebook) are termed <em>sharing users</em>-- any files they upload must be stored in an owning users cloud storage.
              </p>

            <li>Files and fileUUID's</li>
              <p style="margin-left: 1em">
                Files are the main unit of user data storage in SyncServer. 
                These files are stored in a users cloud storage (e.g., Google Drive, Dropbox), and synchronized with a mobile app.
              </p>
              <p style="margin-left: 1em">
                Files are uniquely identified by UUID's. These are called <em>fileUUID</em>'s. 
                Clients are responsible for creating these fileUUID's and giving them to the client interface.
              </p>

            <li><a id="FILE_VERSION"></a>File Versioning</li>
              <p style="margin-left: 1em">
                SyncServer stores files in a versioned manner in the sense that when a new file replaces an existing file in cloud storage, it is stored with the successive next version number. 
                Any prior version is deleted immediately beforehand.
                File versioning is part of a mechanism to make sure apps stay up to date with the latest uploaded data on the server. 
                That is, the most recent version of a file has the contents a client should download.
                File versioning also helps allow concurrent upload of revised file data.
                Much of this versioning is concealed beneath the layer of the iOS client library-- but if you look at the program code, or if you look at the <a href="#FILENAMING">file names in cloud storage</a>, you will see versioning.
              </p>

            <li>App Meta Data</li>
              <p style="margin-left: 1em">
                SyncServer also supports per-file app-specific meta data. This is referred to as <em>appMetaData</em>. 
                This data is stored in the mySQL database used by the server, and for this reason, <a href="#MINIMIZE-APPMETADATA">its use should be minimized in any particular app design</a>.
                The <a href="https://github.com/crspybits/SharedImages">SharedImages app</a> makes use of appMetaData to store more specialized file type information than recorded in the mime type for the file. 
              </p>

            <li>Versioned App Meta Data</li>
              <p style="margin-left: 1em">
                Similar to files, appMetaData is stored in a versioned manner-- when and if the appMetaData is updated for a particular file, the version of the appMetaData gets incremented to the next successive whole number.
                The purpose of this versioning is to enable client apps to stay up to date with the latest versions of the appMetaData for files.
              </p>

            <li><a id="FILE_GROUP"></a>File Groups and fileGroupUUID's</li>
              <p style="margin-left: 1em">
                When an app developer designs a mobile app, it may be convenient to group together collections of files.
                For example, in the <a href="http://github.com/crspybits/SharedImages">SharedImages</a> app, each pair of image and discussion thread text files are considered to be groups.
                These file groupings are supported by SyncServer.
              </p>
              <p style="margin-left: 1em">
                  File Groups are uniquely identified by UUID's. 
                  These are called <em>fileGroupUUID</em>'s. 
                  Clients are responsible for creating these fileGroupUUID's and giving them to the client interface.
              </p>

            <li>Optimistic Synchronization and the Master Version</li>
              <p style="margin-left: 1em">
                Another key element in the design of SyncServer is synchronization.
                The goal is that each mobile app should have a consistent snapshot of the data being shared by a group of users.
                To this end, a type of optimistic synchronization is used.
                The synchronization is optimistic in that it is generally assumed that simultaneous updates of the data being shared by a group of users will be relatively infrequent.
              </p>
              <p style="margin-left: 1em">
                For the data for a group of users, a single integer called the <em>master version</em> is persistently maintained (in the SyncServer mySQL database).
                Each time a group of files is uploaded by an app, the master version is incremented.
                Thus, the master version represents the overall (or <em>master</em>) version of a collection of files (and appMetaData) being shared by a group of users.
                Every time a client app asks for or sends data to the server, it gives what it thinks is the current master version.
                If that master version is actually out of date (i.e., doesn't match the master version known to the server), then the server rejects the client request.
                And then the client must recover from this rejection.
                Since synchronization, and hence these rejections, should occur only infrequently, this recovery should be infrequent.
                This rejection recovery occurs purely within the iOS client layer, and is not seen by the mobile app developer (except perhaps for some event reporting).
              </p>

              <img src="Figures/MasterVersion.png" style="width: 100%; height: auto;"/>
              <p></p>
              <p style="margin-left: 1em">
                The left panel of the above figure depicts a successful exchange between the client app and the SyncServerII server-- the client knows the exact value of the current master version for the sharing group.
                The right panel of the above figure depicts an unsuccessful exchange between the client app and the SyncServerII server-- the client's value for the master version is out of date.
                Note that in the case of an unsuccessful exchange, the client can still perform certain server requests -- for example, the client can do a FileIndex endpoint request to get (a) the current master version value, and (b) the file meta data (<em>not</em> the appMetaData) for the current collection of files in the file sharing group (e.g., fileUUID's, and file versions.
              </p>   

            <li>Privacy, Safety, &amp; Security</li>
              <p style="margin-left: 1em">
                SyncServerII enables data to be safely shared amongst groups of users.
                SyncServerII provides privacy and safety in the sense that the files and other information stored in SyncServer will not be searchable by search engines, and only users who you have granted access to your files get access to the specific set of files in the sharing group in SyncServer.
              </p>
              <p style="margin-left: 1em">
                SyncServerII emphasizes privacy and safety over security (e.g., that security can be in the hands of the developer creating the mobile app and deploying the SyncServer server) -- but if a user is happy with the security of their data in a cloud storage service, e.g., Google Drive or Dropbox, they will likely be happy with the security of storage in SyncServer.
              </p>
              <p style="margin-left: 1em">
                SyncServer <em>does</em> persistently store authorization tokens for the cloud storage service for owning users.
                For example, suppose an owning user is using Google Drive to save their files in a mobile app incorporating SyncServer.
                Then, SyncServer persistently saves an Oauth2 token for accessing Google Drive for that user in its mySQL database.
                It is necessary for SyncServer to store these authentication tokens to enable sharing of a users data, when that sharing is authorized.
                SyncServer <em>never</em> has access to a users username or password on cloud storage services (or other sign-in methods such as Facebook). 
                Sign in is handled using the sign-in mechanism specific to that sign-in method.
              </p>

            <li>File Data Representation</li>
              <p style="margin-left: 1em">
                An intent of SyncServerII based apps is to allow users to own their data. 
                For example, if an app developer stops maintaining an app a user shouldn't be stranded and lose their data. 
                To this end, file data representations should be chosen where that file data content is available to end-users.
              </p>
              <p style="margin-left: 1em">
                For example, two types of files are used in <a href="http://github.com/crspybits/SharedImages">SharedImages</a>: JPEG image files and text files for discussion threads. 
                The image files are directly usable by users. 
                For example, if an owning user stores their files in Google Drive, then they can open their Google Drive and view the images. 
                The text discussion threads are a little more difficult. 
                They are stored in JSON format, and so will likely be cryptic to an end-user. However, *all* of the discussion thread content is present in these files in plain text.
              </p>
              <p style="margin-left: 1em">
                <a id="MINIMIZE-APPMETADATA"></a>
                Similarly, an app developer should make minimal use of the `appMetaData` capabilities of SyncServer. 
                This data is stored in a mySQL database -- and is thus not available to an end-user.
              </p>

            <li>Risks of User Modification of File Data</li>
              <p style="margin-left: 1em">
                Because an app's files live in end-users cloud storage, there is a risk that users might alter or remove these files.
                Currently, SyncServerII has two strategies for dealing with this:
                <ol>
                  <li>Warning file</li>
                    When a user account is first created, <a href="#SERVER_CONFIG">a non-shared file can be written into that users collection of data files</a> (e.g., named "IMPORTANT_README.txt"). 
                    The intent of this file is to warn users not to change or remove the apps data files, unless they are going to discontinue using the app.
                  <li>File Sizes &amp; File checksums</li>
                    Currently, SyncServer uses file sizes to detect changes in files.
                    <a href="https://github.com/crspybits/SyncServerII/issues/63">A planned change to SyncServerII is to incorporate the use of checksums</a>. 
                    This is better because some changes a user might make to a file do not have to be fatal to an app.
                    For example, a user on a MacOS system can easily open an image file and rotate the image. 
                    That change to the file does not need to be fatal to the SharedImages app.
                </ol>
              </p>
          </ul>

          <li><a href="https://github.com/crspybits/SyncServer-iOSClient">Client</a></li>
          <ul>
            <li>Sync and Sync Queues</li>
              <p style="margin-left: 1em">
                  A typical pattern of using 
                  <a href="https://github.com/crspybits/SyncServer-iOSClient">the iOS client interface</a>
                   is the following:
              </p>
<pre>
  <code>
    do {
        try SyncServer.session.uploadImmutable(localFile: url1, withAttributes: attr1)
        try SyncServer.session.uploadImmutable(localFile: url1, withAttributes: attr2)
    } catch {
    }

    SyncServer.session.sync()
  </code>
</pre>

              <p style="margin-left: 1em">
                  That is, you typically queue up some files for upload (e.g., using uploadImmutable) and then call `sync`.
                  Each time you call the `sync` method of the SyncServer iOS client, the current pending queue of upload items is "closed", and readied for upload. 
                  This collection of files is uploaded atomically-- either all of the files make it to the server, or none of the files make it.
                  A suitable use of this capability is to only call `sync` when you have queued uploads for all files in a single <a href="#FILE_GROUP">file group</a>.
              </p>

            <li>Download Prioritization</li>
              <p style="margin-left: 1em">
                The server, and the cloud storage it references, is generally taken to be the "source of truth" -- or real value of data.
                Therefore, downloads from the server to the client are prioritized over uploads from the client to the server.
                This prioritization of downloads has an impact on how we discuss conflicts -- we talk about conflicts as stemming from downloads, though they involve an interaction between changes on the server and changes on the client.
              </p>

            <li>Conflicts and Conflict Resolution</li>
              <img src="Figures/Conflicts.png" style="width: 100%; height: auto;"/>
              <p></p>
              <p style="margin-left: 1em">
                The left and right panels of the above figure illustrate the two main categories of conflicts: Content download conflicts and download deletion conflicts.
              </p>

              <p style="margin-left: 1em">
                Consider the <a href="http://github.com/crspybits/SharedImages">SharedImages app</a>, and suppose that user Chris makes a discussion thread comment, and the app uploads that comment.
                Next, without first refreshing, another user, Dany, in the same group comments on the same image.
                This is now a conflict situation: The comment thread (a file) referenced by the server, as modified by Chris, is different than the file that Dany's app is uploading.
                Dealing with these conflicts is known as conflict resolution.
                Similarly, a conflict can also occur if Chris deletes a file (say, an image and discussion thread in SharedImages), uploads that change to the server, and Dany, without first refreshing, makes a modification to the discussion thread associated with that image.
              </p>
              <p style="margin-left: 1em">
                The SyncServer client leaves the details of conflict resolution decisions to the app developer, but provides some mechanisms to assist in this process.
                One reason that the details of conflict resolution are left to the app developer is because app developers can choose representations, in some cases, to make conflict resolution easier.
                For example, in the first conflict situation above, between two changes in a discussion thread file, SharedImages handles this relatively easily by disallowing individual comments to be modified, by giving each discussion comment a unique identifier, and by putting timestamps onto each comment.
                These app-specific decisions enable two conflicting versions of the same discussion thread file to be easily merged, and thus conflict resolution in this case is simplified.
              </p>
              <p style="margin-left: 1em">
                The SyncServer client provides mechanisms to assist in dealing with conflicts in the following manner. 
                First, conflicts are categorized into <em>content download</em> and <em>download deletion</em> conflicts.
                Content download conflicts are conflicts between a modified file and/or appMetaData being downloaded from the server, and the same file and/or appMetaData, modified (or deleted) by the local user and being uploaded.
                When these conflicts occur, the following SyncServer delegate method is called:
              </p>
                <pre>
                  <code>
func syncServerMustResolveContentDownloadConflict(
    _ downloadContent: ServerContentType, 
    downloadedContentAttributes: SyncAttributes, 
    uploadConflict: SyncServerConflict<ContentDownloadResolution>)
                  </code>
                </pre>
              <p style="margin-left: 1em">
                The above delegate method enables client apps to choose how they want to deal with the content download conflict.
                For example, a client app might choose to always prioritize downloads from the server and ignore conflicting uploads.
              </p>

              <p style="margin-left: 1em">
                Download deletion conflicts are between a file that was deleted on the server, and the same file and/or appMetaData having been modified or deleted locally and being uploaded.
                When these conflicts occur, the following SyncServer delegate method is called:
              </p>
                <pre>
                  <code>
func syncServerMustResolveDownloadDeletionConflicts(
    conflicts:[DownloadDeletionConflict]) 
                  </code>
                </pre>

              <p style="margin-left: 1em">
                  The above delegate method enables client apps to choose how they want to deal with the download deletion conflicts.
                  For example, a client app might choose to always prioritize download deletions from the server and ignore conflicting uploads.
                </p>

              <p style="margin-left: 1em">
                See also <a href="https://crspybits.github.io/iOS-Client-Docs/Conflict%20Resolution.html">https://crspybits.github.io/iOS-Client-Docs/Conflict%20Resolution.html</a> and <a href="https://crspybits.github.io/iOS-Client-Docs/Protocols/SyncServerDelegate.html">https://crspybits.github.io/iOS-Client-Docs/Protocols/SyncServerDelegate.html</a>.
              </p>
          </ul>

          <li><a href="https://github.com/crspybits/SyncServerII">Server</a></li>
          <ul>
            <li>A single server supports a single type of app.</li>
              <p style="margin-left: 1em">
                  E.g., suppose you have two apps, each with different Apple iOS bundle id's-- then you'll need to run two different SyncServers.
              </p>
            
            <li><a id="FILENAMING"></a>File naming and file name extensions</li>
            <p style="margin-left: 1em">
              Files are uploaded from clients to cloud storage with the naming convention: 
            <br>
            &nbsp;&nbsp;&nbsp;&nbsp;<em>fileUUID</em>.<em style="color:green">deviceUUID</em>.<em>fileVersion</em>.<em style="color:green">FileExtension</em>
            </p>
            <p style="margin-left: 1em">
              A <em>deviceUUID</em> is an identifier assigned by the SyncServer iOS client library to the particular device to identify it to the server.
              The <em>fileVersion</em> is an integer corresponding to the <a href="#FILE_VERSION">file version as discussed above</a>.
              We do not use just the fileUUID to name the file in the cloud service because the server does not hold a lock across multiple file uploads, and we need to make sure that we don't have a conflict when two or more devices attempt to concurrently upload the same file. 
              <em>FileExtension</em>'s correspond directly to the mime type of a file used when uploading using the client interface.
            </p>
            <p style="margin-left: 1em">For example, here is an example of files stored in a Google Drive account by the SharedImages app:
            </p>
            <p></p>
            <img src="Figures/SharedImagesFiles.png" style="width: 100%; height: auto;"/>
            <p></p>
            <p style="margin-left: 1em">
              In the above figure, you can notice that all of the image (.jpg) file are at version 0-- SharedImages doesn't generally let you modify an image once uploaded.
              You can also notice that some of the .txt files (used for discussion threads) are at versions &gt; 0-- this is because various users of the SharedImages app contribute to the discussion threads, and upload different versions of discussion thread files corresponding to those changes.
            </p>
          </ul>
        </ul>
      </div>

      <a class="anchor" id="CLIENT_API"></a>
      <div class="row row-striped padded">
        <h2>Client Interface Documentation</h2>
        <p style="margin-left: 1em">
        <a href="https://crspybits.github.io/iOS-Client-Docs/">The API for the iOS client interface is documented here.</a>
        </p>
      </div>

      <a class="anchor" id="LIMITATIONS"></a>
      <div class="row row-striped padded">
        <h2>Current Limitations</h2>
        <ul>
          <li><a href="https://github.com/crspybits/SyncServerII/issues/74">
            Only the initial user in a sharing group can be the owning user.</a>     
          </li>
          <li><a href="https://github.com/crspybits/SyncServerII/issues/27">
            A user can only be a member of a single sharing group.</a></li>
          <li>No streaming or chunking of file uploads/downloads</li>
            This will presumably result in file size limitations and/or performance limitations with the server.
          <li><a href="https://github.com/crspybits/SyncServerII/issues/63">No file checksums yet</a>.</li>
          <li>Cryptic file names in cloud storage.</li>
            It would be good to have an <a href="https://github.com/crspybits/SyncServerII/issues/68">index.html</a> file that could let the users see the purpose of the files in some organized manner.
        </ul>
      </div>
      
      <a class="anchor" id="INSTALLSERVER"></a>
      <div class="row row-striped padded">
        <h2>Standing up a Server</h2>
        <div style="margin-left: 1em">
          <p>Each separate mobile app needs its own server. That is, for iOS, each app with a separate bundle id needs its own server.</p>

          <p>I have gone through a few incarnations of methods for installing the server, each of them on AWS. Currently, I am using a Docker image, and also use AWS Elastic Beanstalk. <a href="runningServerOnEC2.html">Previously, I was building the server directly on an AWS EC2 instance.</a></p>

          <p>The two basic parts of my current deployment method are described below.</p>

          <h3>Docker</h3>
          <p><a href="https://www.docker.com">Docker</a> is now central to my testing and deployment process for the server.
            For testing, I use the <a href="https://github.com/crspybits/SyncServerII/blob/master/devops/Docker/Building/Dockerfile">same Docker image that I use for building</a>.
          </p>

          <p>On my system, the following command launches that Docker image:</p>
          <code>docker run --rm -i -t -v /Users/chris/Desktop/Apps/:/root/Apps crspybits/swift-ubuntu:4.0.0</code>
          <p>And, of course, the path `/Users/chris/Desktop/Apps/` is specific to my system.</p>

          <p>And running under that Docker image, this builds the server:</p>
          <code>swift build -Xswiftc -DDEBUG -Xswiftc -DSERVER</code>
          <p></p>
          <p>For runtime, I use <a href="https://github.com/crspybits/SyncServerII/blob/master/devops/Docker/Runtime/Dockerfile"> this Docker base-image</a> 
          and I <a href="https://github.com/crspybits/SyncServerII/blob/master/devops/release.sh">run the script</a> to create a Docker image for a specific release of the SyncServerII server code. Those release builds of the server Docker images live at <a href="https://hub.docker.com/r/crspybits/syncserver-runner/">hub.docker.</a>
          </p>

          <h3>AWS Elastic Beanstalk</h3>
          <p>I use <a href="https://aws.amazon.com/elasticbeanstalk/">AWS's Elastic Beanstalk</a> for reasons including: 
            <ol style="list-style-type: lower-alpha">
              <li>ease of deploying new versions of my server</li>
              <li>its ability to run servers from Docker images</li>
              <li>the relative ease of spinning up (and down) of new server environments-- so I can create and use a staging or testing environment for just a few hours</li>
              <li>my (potential) eventual need for scaling the server to deal with a larger load from client apps.</li>
            </ol>
          </p>
          <p>
          My <a href="https://github.com/crspybits/SyncServerII/blob/master/devops/AWS-ElasticBeanstalk/Docs/LaunchingEnvironment.md">deployment process to the AWS Elastic Beanstalk</a> takes several steps, some of them manual.
          </p>

          <h3><a id="SERVER_CONFIG"></a>Server configuration</h3>
          <p>
          When the server starts, it reads configuration information from a JSON file. 
          The following details the format of that configuration file.
          </p>
          <pre>
            <code>
  {
    "mySQL.host": "URL-for-mySQL-server",
    "mySQL.user": "usernameForMySQL",
    "mySQL.password": "passwordForMySQL",
    "mySQL.database": "mySQL-database-name",
    "port": "8080",
    "allowedSignInTypes.Facebook": "true",
    "allowedSignInTypes.Google": "true",
    "allowedSignInTypes.Dropbox": "true",
    "ssl.selfSigning": "false",
    "GoogleServerClientId": "Get this when you create your Google app",
    "GoogleServerSecret": "as above",
    "FacebookClientId" : "Get this when you create your Facebook app",
    "FacebookClientSecret": "as above",
    "owningUserAccountCreation.initialFileName": "IMPORTANT_README.txt",
    "owningUserAccountCreation.initialFileContents": "IMPORTANT: The files placed in this directory should not be changed in any way. They were created by the EXAMPLE app. If they are changed, that can cause the EXAMPLE app to crash or behave unpredictably. Of course, if you want to stop using EXAMPLE, these are your files, and you are fully able to use them as you wish."
  }
            </code>
          </pre>
        
          <p>
            When a new owning user account is created (i.e., one with cloud storage), a single non-shareable file is first created. That file has a name given by <em>owningUserAccountCreation.initialFileName</em> and contents given by <em>owningUserAccountCreation.initialFileContents</em>. 
            The intent is that this file serves as a warning to users to not modify the files used by the app.
          </p>
        </div>
      </div>

      <a class="anchor" id="INSTALLAPP"></a>
      <div class="row row-striped padded">
        <h2>Installation in a new iOS app</h2>
        <div style="margin-left: 1em">
          <p>The best instructions for setting up a new iOS app are likely found by looking over the <a href="http://github.com/crspybits/SharedImages">SharedImages</a> app, but some details are also given below.</p>
          
          <p>The <a href="https://github.com/crspybits/SyncServer-iOSClient">example app in the iOS client repo</a> can also provide information on setting up your iOS app.</p>

          <ol id="PODFILE">
            <li>Setup your <em>Podfile</em>. </li>
                The SyncServer iOS client API is a Cocoapod. 
                Google Drive and Dropbox are the current options for cloud storage.
                Facebook can be used to allow shared sign-in's, and is optional.
  <pre>
  # Some pods used by SyncServer haven't yet been released to cocoapods.org, so the following is needed.
  source 'https://github.com/crspybits/Specs.git'
  source 'https://github.com/CocoaPods/Specs.git'

  use_frameworks!

  target 'YourApp' do
      # The iOS client.
      pod 'SyncServer'
      
      # Only needed if you are allowing Facebook users to share.
      pod 'SyncServer/Facebook'

      # Only needed if you are using Dropbox for cloud storage
      pod 'SyncServer/Dropbox'
      
      # Only needed if you are using Google Drive for cloud storage
      pod 'SyncServer/Google'
      
      target 'YourAppTests' do
          inherit! :search_paths
      end
  end
  </pre>

            <li>Additions to your AppDelegate</li>
            
            <ol type="a">
              <li>Add the following import</li>
                <pre>import SyncServer</pre>

              <li>Setup your sign-in's in the didFinishLaunchingWithOptions method</li>
                If you are allowing use of Google Drive, you will need:
  <pre>
  let googleSignIn = GoogleSyncServerSignIn(serverClientId: serverClientId, appClientId: appClientId)
  SignInManager.session.addSignIn(googleSignIn, launchOptions: options)        
  </pre>

                If you are also using Dropbox, you'll need:
  <pre>
  let dropboxSignIn = DropboxSyncServerSignIn(appKey: dropboxAppKey)
  SignInManager.session.addSignIn(dropboxSignIn, launchOptions: options)
  </pre>

              If you are also using Facebook sign-in, you'll need:
  <pre>
  let facebookSignIn = FacebookSyncServerSignIn()
  SignInManager.session.addSignIn(facebookSignIn, launchOptions: options)
  </pre>     


              
                <div style="position:relative; left: 2em;">
                Where: <em>serverClientId</em> and <em>appClientId</em> come from setting up your app with Google. See below.
                </div>
              
              <li>Also in the didFinishLaunchingWithOptions method, you need to call</li>
                <pre>SyncServer.session.appLaunchSetup(withServerURL: serverURL, cloudFolderName:cloudFolderName)</pre>
                <div style="position:relative; left: 2em;">
                Where: 
                <ul>
                  <li><em>serverURL</em> is the URL of your SyncServer server. </li>

                  <li><em>cloudFolderName</em> is the folder name (not a path, just a folder) within Google Drive in which your files will be stored (if you are using Google Drive). Dropbox, if you are using that, doesn't need this.</li> 
                    E.g., I'm using "SharedImages.Folder" for the SharedImages app.  
                </ul>
                </div>
                      
              <li>Add the following into the app:open:options: method</li>
  <pre>
  func application(_ app: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {
      return SignInManager.session.application(app, open: url, options: options) ||
      SharingInvitation.session.application(app, open: url, options: options)
  }
  </pre>         

              <li>To enable background downloading/uploading add this into your AppDelegate</li>
  <pre>
  func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) {
    SyncServer.session.application(application, handleEventsForBackgroundURLSession: identifier, completionHandler: completionHandler)
  }
  </pre>
            </ol>
            
            <li>Setup the <em>SharingInvitationDelegate</em> to deal with sharing invitations received.</li>
                For an example of how this is done, search for <em>SharingInvitationDelegate</em> in the <a href="http://github.com/crspybits/SharedImages">SharedImages</a> app.
            
            <li>Setup the UI for sign-in's in your app.</li>
              <ol type="a">
                You will need to do this for at least Google.
                      For an example of how this is done, look in the <a href="http://github.com/crspybits/SharedImages">SharedImages</a> app.
                <li>Call the `setupSignInButton` and setup delegates for your selected sign-ins. For example:</li>
  <pre>
  // For the GoogleSyncServerSignIn, the delegate in this params argument must a view controller abiding by GoogleSignInUIProtocol
  let googleSignInButton = googleSignIn.setupSignInButton(params: ["delegate": self])
  googleSignIn.delegate = self // abiding by GenericSignInDelegate

  // If you are using Facebook sign-in:
  let facebookSignInButton = facebookSignIn.setupSignInButton(params:nil)
  // Just to balance out the lengths of the sign-in buttons-- the Google button is shorter.
  facebookSignInButton.frameWidth = googleSignInButton.frameWidth
  facebookSignIn.delegate = self

  // If you are using Dropbox sign-in:
  let dropboxSignInButton = dropboxSignIn.setupSignInButton(params: ["viewController": self])
  dropboxSignInButton.frameSize = CGSize(width: googleSignInButton.frameWidth, height: googleSignInButton.frameHeight * 0.75)
  dropboxSignIn.delegate = self
  </pre>
                
                <li>For convenience if you are using multiple sign-in's (say, Google, Facebook, and Dropbox, the SyncServer <em>SignIn</em> widget can enable you to display the sign-in's automatically:</li>
                
  <pre>
  let signIn:SignIn = SignIn.createFromXib()!
  // and add this SignIn view into an appropriate view controller in your UI.
  </pre>
                The SignIn view uses the SyncServer SignInManager to determine which sign-in buttons to display. The <a href="http://github.com/crspybits/SharedImages">SharedImages</a> app uses the SignIn view, so see that for additional code details.
              </ol>
          </ol>
        </div>
      </div>
      
      <a class="anchor" id="GOOGLE"></a>
      <div class="row row-striped padded">
        <h2>Using Google Drive and Google Sign-In (optional)</h2>
        <ol>
          <li>Create Google App/Developer Credentials</li>
            To enable access to user Google Drive accounts, you must create Google Developer credentials for your iOS app and SyncServer server. These credentials need to be installed in your app making use of the SyncServer client Framework. Go to <a href="https://developers.google.com/identity/sign-in/ios/start">https://developers.google.com/identity/sign-in/ios/start</a>. 
            <p></p>
            <p>You need to generate a configuration file-- this will typically be named: `GoogleService-Info.plist`, and add that file to your Xcode project. Amongst other information, this .plist file contains the Google `CLIENT_ID` for your iOS app.</p>

          <li>You also need to make sure you enable the Google Drive API for your Google project.</li>
           You can do this by going to <a href="https://console.developers.google.com">https://console.developers.google.com</a>, looking for `ENABLE API`, and then `Drive API`.
          
          <li>Obtain your `OAuth 2.0 client IDs`.</li>
            Within <a href="https://console.developers.google.com">https://console.developers.google.com</a>, you also need to obtain the `OAuth 2.0 client IDs` for your `Web client` (see under "Credentials).
            In the SyncServer configuration file this is called the <a href="#SERVER_CONFIG">GoogleServerClientId</a>. You will need both the `CLIENT_ID` (for your iOS app) and the GoogleServerClientId (for the SyncServer server) in order for users to sign in to Google Drive from your iOS app.
          
          <li>Add URL scheme for Google Sign in to your app.</li>
            You do this in XCode under the "Info" tab. Look for "URL Types" and paste the CLIENT_ID into the "URL Schemes" field of a new URL Type (press the "+" button).
        </ol>
      </div>

      <a class="anchor" id="FACEBOOK"></a>
      <div class="row row-striped padded">
        <h2>Using Facebook Sign-In (optional)</h2>
        <ol>
          <li>Create a new Facebook app</li>
            To do this, go to <a href="https://developers.facebook.com">https://developers.facebook.com</a>.
            You will need to sign in with a Facebook account. If you don't already have one, you'll have to make one.
          
            After signing in, in the upper right, under "My Apps", click on "Add a New App". Follow the instructions. They're pretty good.
          
          <li>For the Server: ClientId and Secret.</li>
            You will need the <a href="#SERVER_CONFIG">FacebookClientId</a> (App ID) and <a href="#SERVER_CONFIG">FacebookClientSecret</a> (App Secret) for the SyncServer server Server.json file from your new app on <a href="https://developers.facebook.com">https://developers.facebook.com</a>.
        </ol>        
      </div>

      <a class="anchor" id="DROPBOX"></a>
      <div class="row row-striped padded">
        <h2>Using Dropbox Sign-In and Cloud Storage (optional)</h2>
        <ol>
          <li>Register your application with Dropbox</li>
            To do this, use <a href="https://www.dropbox.com/developers/apps">this Dropbox link</a>. The <a href="https://github.com/dropbox/SwiftyDropbox#get-started">more general Dropbox docs are here</a>.
          <li>Configure your project</li>
          You will need to then follow the steps under "Configure your project" in the <a href="https://github.com/dropbox/SwiftyDropbox#get-started">more general Dropbox docs</a>. You do *not* need to explicitly include the Dropbox Cocoapod in your Podfile for your Xcode project if you have followed the above <a href="#PODFILE">Podfile instructions</a>.
        </ol>        
      </div>
      
      <a class="anchor" id="FURTHERREADING"></a>
      <div class="row row-striped padded">
        <h2>Further Reading</h2>
        <ol>
            <li>Talk given at roster technologies brown bag lunch series (2/6/18)</li>
            <a href="presentations/SyncServerII-2-6-18.pptx">PowerPoint slides</a>
            <a href="https://youtu.be/VK_nKxd6njo">YouTube video.</a>

          <li>Talk given to the Boulder iOS Meetup (11/21/17)</li>
            <a href="presentations/SyncServerII-11-21-17.pptx">PowerPoint slides</a>
            <a href="https://youtu.be/Xid_vZ3nlCQ">YouTube video (teaser-- first 10 minutes! :) ).</a>
          
          <li>Talk given to the Denver Open Source Users Group (8/1/17)</li>
            <a href="presentations/SyncServerII-8-1-17.pptx">PowerPoint slides</a>
          
          <li>Blog articles on SyncServer development</li>
          <ol type="a">
            <li><a href="http://www.spasticmuffin.biz/blog/2017/11/18/the-client-side-syncserver-sign-in-system-making-sign-in-sticky/">The Client-Side SyncServer Sign-In System: Making Sign-in Sticky</a> (10/23/17)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2017/09/15/making-downloads-more-flexible-in-the-syncserver/">Making Downloads More Flexible in the SyncServer</a> (9/15/17)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2016/09/03/to-lock-or-not-to-lock-in-the-smsyncserver/">To Lock or Not to Lock in the SMSyncServer</a> (9/3/16)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2016/05/11/conflict-management-in-the-smsyncserver/">Conflict Management in the SMSyncServer</a> (5/11/16)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2016/05/09/re-architecting-the-smsyncserver-file-system/">Re-Architecting the SMSyncServer File System</a> (5/9/16)</li>

            <li><a href="http://www.spasticmuffin.biz/blog/2016/04/26/the-many-senses-of-recovery-in-smsyncserver/">The Many Senses of Recovery in SMSyncServer</a> (4/26/16)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2016/04/02/design-issue-changing-cloud-storage-accounts-with-the-smsyncserver/">Design Issue: Changing Cloud Storage Accounts With The SMSyncServer</a> (4/2/16)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2016/01/21/blitz-to-get-smsyncserver-ready-for-open-source/">Blitz to get SMSyncServer Ready for Open-Source</a> (1/21/16)</li>
            
            <li><a href="http://www.spasticmuffin.biz/blog/2015/12/29/the-syncserver-permanent-access-to-your-app-data/">The SyncServer: Permanent Access to Your App Data</a> (12/29/15)</li>
          </ol>
        </ol>        
      </div>
      
      <hr>

      <footer>
        <p>&copy; SyncServer and associated software is MIT licensed.</p>
      </footer>
    </div> <!-- /container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="jquery.min.js"><\/script>')</script>

    <script src="bootstrap.min.js"></script>
    
    <script src="ie10-viewport-bug-workaround.js"></script>
  </body>
</html>